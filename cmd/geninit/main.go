package main

import (
	"cmp"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"slices"
	"strings"
	"text/template"
)

func main() {
	symbolSpecs, err := ParseSymbolSpecsFromDirectory("./builtins")
	if err != nil {
		fmt.Printf("Error: %s\n", err)
		os.Exit(1)
	}

	// sort by symbol
	slices.SortFunc(symbolSpecs, func(a, b SymbolSpec) int {
		return cmp.Compare(a.Name, b.Name)
	})

	// add Protected if missing
	for i, s := range symbolSpecs {
		if !slices.Contains(s.Attributes, "Protected") {
			s.Attributes = append(s.Attributes, "Protected")
		}
		slices.SortFunc(s.Attributes, func(a, b string) int {
			return cmp.Compare(a, b)
		})
		symbolSpecs[i].Attributes = s.Attributes
	}

	names := make([]string, len(symbolSpecs))

	for i, s := range symbolSpecs {
		names[i] = s.Name
	}
	genAtoms(names)

	//
	// Create and execute template
	t, err := template.New("setup").Parse(setupTemplate)
	if err != nil {
		panic("Can't parse template")
	}
	// Generate code
	var buf strings.Builder
	err = t.Execute(&buf, symbolSpecs)
	if err != nil {
		panic("Can't execute template: " + err.Error())
	}

	// Format the generated code
	raw := buf.String()
	formatted, err := format.Source([]byte(raw))
	if err != nil {
		fmt.Println(raw)
		panic("Unable for format code")
	}

	fmt.Println(string(formatted))

	if false {

		// DUMP as map
		mapping := make(map[string]SymbolSpec, len(symbolSpecs))
		for _, spec := range symbolSpecs {
			mapping[spec.Name] = spec
		}

		raw, err := json.MarshalIndent(mapping, "", "    ")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			os.Exit(1)
		}

		fmt.Println(string(raw))
		fmt.Println(len(mapping))
	}

}

var setupTemplate = `// Code generated by wrapgen. DO NOT EDIT.

package sexpr

import (
        "fmt"
        "github.com/client9/sexpr/builtins"
        "github.com/client9/sexpr/engine"
)

// SetupBuiltinAttributes sets up standard attributes for built-in functions
func SetupBuiltinAttributes(symbolTable *engine.SymbolTable) {	
{{- range $sym := $ }}
    symbolTable.SetAttributes("{{ $sym.Name }}",  []engine.Attribute{ 
        {{- range $sym.Attributes }}engine.{{.}},{{ end -}}
    })
{{- end }}
}

// RegisterDefaultBuiltins registers all built-in functions with their patterns
func RegisterDefaultBuiltins(registry *engine.FunctionRegistry) {
        // Register built-in functions with pattern-based dispatch
        builtinPatterns := []engine.PatternRule{
{{- range $sym := $ }}{{ range $sym.Functions }}
{"{{ $sym.Name }}{{ .Pattern }}", {{ .Function }}},
{{- end }}{{ end }}
	}

        err := registry.RegisterPatternBuiltins(builtinPatterns)
        if err != nil {
                panic(fmt.Sprintf("Failed to register builtin patterns: %v", err))
        }
}
`
