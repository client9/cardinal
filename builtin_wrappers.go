// Code generated by wrapgen; DO NOT EDIT.

package sexpr

// WrapPlusIntegers wraps PlusIntegers for the pattern system
// Generated from pattern: Plus(x__Integer)
func WrapPlusIntegers(args []Expr, ctx *Context) Expr {
	funcName := "Plus"

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		if atom, ok := args[0].(Atom); ok && atom.AtomType == IntAtom {
			return args[0] // Return directly
		}
		// Fall back to original if not integer
		return CopyExprList(funcName, args)
	}

	// Convert all args to int64
	convertedArgs := make([]int64, len(args))
	for i, arg := range args {
		if val, ok := ExtractInt64(arg); ok {
			convertedArgs[i] = val
		} else {
			// Type mismatch - return unchanged
			return CopyExprList(funcName, args)
		}
	}

	// Call business logic function
	result := PlusIntegers(convertedArgs...)

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapPlusReals wraps PlusReals for the pattern system
// Generated from pattern: Plus(x__Real)
func WrapPlusReals(args []Expr, ctx *Context) Expr {
	funcName := "Plus"

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		if atom, ok := args[0].(Atom); ok && atom.AtomType == FloatAtom {
			return args[0] // Return directly
		}
		// Fall back to original if not real
		return CopyExprList(funcName, args)
	}

	// Convert all args to float64
	convertedArgs := make([]float64, len(args))
	for i, arg := range args {
		if val, ok := ExtractFloat64(arg); ok {
			convertedArgs[i] = val
		} else {
			// Type mismatch - return unchanged
			return CopyExprList(funcName, args)
		}
	}

	// Call business logic function
	result := PlusReals(convertedArgs...)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapTimesIntegers wraps TimesIntegers for the pattern system
// Generated from pattern: Times(x__Integer)
func WrapTimesIntegers(args []Expr, ctx *Context) Expr {
	funcName := "Times"

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		if atom, ok := args[0].(Atom); ok && atom.AtomType == IntAtom {
			return args[0] // Return directly
		}
		// Fall back to original if not integer
		return CopyExprList(funcName, args)
	}

	// Convert all args to int64
	convertedArgs := make([]int64, len(args))
	for i, arg := range args {
		if val, ok := ExtractInt64(arg); ok {
			convertedArgs[i] = val
		} else {
			// Type mismatch - return unchanged
			return CopyExprList(funcName, args)
		}
	}

	// Call business logic function
	result := TimesIntegers(convertedArgs...)

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapTimesReals wraps TimesReals for the pattern system
// Generated from pattern: Times(x__Real)
func WrapTimesReals(args []Expr, ctx *Context) Expr {
	funcName := "Times"

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		if atom, ok := args[0].(Atom); ok && atom.AtomType == FloatAtom {
			return args[0] // Return directly
		}
		// Fall back to original if not real
		return CopyExprList(funcName, args)
	}

	// Convert all args to float64
	convertedArgs := make([]float64, len(args))
	for i, arg := range args {
		if val, ok := ExtractFloat64(arg); ok {
			convertedArgs[i] = val
		} else {
			// Type mismatch - return unchanged
			return CopyExprList(funcName, args)
		}
	}

	// Call business logic function
	result := TimesReals(convertedArgs...)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapPlusNumbers wraps PlusNumbers for the pattern system
// Generated from pattern: Plus(x__Number)
func WrapPlusNumbers(args []Expr, ctx *Context) Expr {

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		return args[0]
	}

	// Convert all args to Expr
	convertedArgs := make([]Expr, len(args))
	for i, arg := range args {
		convertedArgs[i] = arg
	}

	// Call business logic function
	result := PlusNumbers(convertedArgs...)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapTimesNumbers wraps TimesNumbers for the pattern system
// Generated from pattern: Times(x__Number)
func WrapTimesNumbers(args []Expr, ctx *Context) Expr {

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		return args[0]
	}

	// Convert all args to Expr
	convertedArgs := make([]Expr, len(args))
	for i, arg := range args {
		convertedArgs[i] = arg
	}

	// Call business logic function
	result := TimesNumbers(convertedArgs...)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapPowerReal wraps PowerReal for the pattern system
// Generated from pattern: Power(base_Real, exp_Integer)
func WrapPowerReal(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"PowerReal expects 2 arguments", args)
	}

	arg0, ok := ExtractFloat64(args[0])
	if !ok {
		return CopyExprList("FUNC", args)
	}
	arg1, ok := ExtractInt64(args[1])
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := PowerReal(arg0, arg1)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapSubtractIntegers wraps SubtractIntegers for the pattern system
// Generated from pattern: Subtract(x_Integer, y_Integer)
func WrapSubtractIntegers(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"SubtractIntegers expects 2 arguments", args)
	}

	arg0, ok := ExtractInt64(args[0])
	if !ok {
		return CopyExprList("FUNC", args)
	}
	arg1, ok := ExtractInt64(args[1])
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := SubtractIntegers(arg0, arg1)

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapSubtractNumbers wraps SubtractNumbers for the pattern system
// Generated from pattern: Subtract(x_Number, y_Number)
func WrapSubtractNumbers(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"SubtractNumbers expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := SubtractNumbers(arg0, arg1)

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapDivideIntegers wraps DivideIntegers for the pattern system
// Generated from pattern: Divide(x_Integer, y_Integer)
func WrapDivideIntegers(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"DivideIntegers expects 2 arguments", args)
	}

	arg0, ok := ExtractInt64(args[0])
	if !ok {
		return CopyExprList("FUNC", args)
	}
	arg1, ok := ExtractInt64(args[1])
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result, err := DivideIntegers(arg0, arg1)
	if err != nil {
		return NewErrorExpr(err.Error(), err.Error(), args)
	}

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapDivideNumbers wraps DivideNumbers for the pattern system
// Generated from pattern: Divide(x_Number, y_Number)
func WrapDivideNumbers(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"DivideNumbers expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result, err := DivideNumbers(arg0, arg1)
	if err != nil {
		return NewErrorExpr(err.Error(), err.Error(), args)
	}

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapPowerNumbers wraps PowerNumbers for the pattern system
// Generated from pattern: Power(x_Number, y_Number)
func WrapPowerNumbers(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"PowerNumbers expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result, err := PowerNumbers(arg0, arg1)
	if err != nil {
		return NewErrorExpr(err.Error(), err.Error(), args)
	}

	// Convert result back to Expr
	return NewFloatAtom(result)
}

// WrapEqualExprs wraps EqualExprs for the pattern system
// Generated from pattern: Equal(x_, y_)
func WrapEqualExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"EqualExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := EqualExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapUnequalExprs wraps UnequalExprs for the pattern system
// Generated from pattern: Unequal(x_, y_)
func WrapUnequalExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"UnequalExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := UnequalExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapLessExprs wraps LessExprs for the pattern system
// Generated from pattern: Less(x_, y_)
func WrapLessExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"LessExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := LessExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapGreaterExprs wraps GreaterExprs for the pattern system
// Generated from pattern: Greater(x_, y_)
func WrapGreaterExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"GreaterExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := GreaterExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapLessEqualExprs wraps LessEqualExprs for the pattern system
// Generated from pattern: LessEqual(x_, y_)
func WrapLessEqualExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"LessEqualExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := LessEqualExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapGreaterEqualExprs wraps GreaterEqualExprs for the pattern system
// Generated from pattern: GreaterEqual(x_, y_)
func WrapGreaterEqualExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"GreaterEqualExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := GreaterEqualExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapSameQExprs wraps SameQExprs for the pattern system
// Generated from pattern: SameQ(x_, y_)
func WrapSameQExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"SameQExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := SameQExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapUnsameQExprs wraps UnsameQExprs for the pattern system
// Generated from pattern: UnsameQ(x_, y_)
func WrapUnsameQExprs(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"UnsameQExprs expects 2 arguments", args)
	}

	arg0 := args[0]
	arg1 := args[1]

	// Call business logic function
	result := UnsameQExprs(arg0, arg1)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapIntegerQExpr wraps IntegerQExpr for the pattern system
// Generated from pattern: IntegerQ(x_)
func WrapIntegerQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"IntegerQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := IntegerQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapFloatQExpr wraps FloatQExpr for the pattern system
// Generated from pattern: FloatQ(x_)
func WrapFloatQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"FloatQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := FloatQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapNumberQExpr wraps NumberQExpr for the pattern system
// Generated from pattern: NumberQ(x_)
func WrapNumberQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"NumberQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := NumberQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapStringQExpr wraps StringQExpr for the pattern system
// Generated from pattern: StringQ(x_)
func WrapStringQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"StringQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := StringQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapBooleanQExpr wraps BooleanQExpr for the pattern system
// Generated from pattern: BooleanQ(x_)
func WrapBooleanQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"BooleanQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := BooleanQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapSymbolQExpr wraps SymbolQExpr for the pattern system
// Generated from pattern: SymbolQ(x_)
func WrapSymbolQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"SymbolQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := SymbolQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapListQExpr wraps ListQExpr for the pattern system
// Generated from pattern: ListQ(x_)
func WrapListQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"ListQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := ListQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapAtomQExpr wraps AtomQExpr for the pattern system
// Generated from pattern: AtomQ(x_)
func WrapAtomQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"AtomQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := AtomQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapHeadExpr wraps HeadExpr for the pattern system
// Generated from pattern: Head(x_)
func WrapHeadExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"HeadExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := HeadExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapFullFormExpr wraps FullFormExpr for the pattern system
// Generated from pattern: FullForm(x_)
func WrapFullFormExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"FullFormExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := FullFormExpr(arg0)

	// Convert result back to Expr
	return NewStringAtom(result)
}

// WrapInputFormExpr wraps InputFormExpr for the pattern system
// Generated from pattern: InputForm(x_)
func WrapInputFormExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"InputFormExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := InputFormExpr(arg0)

	// Convert result back to Expr
	return NewStringAtom(result)
}

// WrapLengthExpr wraps LengthExpr for the pattern system
// Generated from pattern: Length(x_)
func WrapLengthExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"LengthExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := LengthExpr(arg0)

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapStringLengthStr wraps StringLengthStr for the pattern system
// Generated from pattern: StringLength(x_String)
func WrapStringLengthStr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"StringLengthStr expects 1 arguments", args)
	}

	arg0, ok := ExtractString(args[0])
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := StringLengthStr(arg0)

	// Convert result back to Expr
	return NewIntAtom(int(result))
}

// WrapFirstExpr wraps FirstExpr for the pattern system
// Generated from pattern: First(x_List)
func WrapFirstExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"FirstExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(List)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := FirstExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapLastExpr wraps LastExpr for the pattern system
// Generated from pattern: Last(x_List)
func WrapLastExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"LastExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(List)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := LastExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapRestExpr wraps RestExpr for the pattern system
// Generated from pattern: Rest(x_List)
func WrapRestExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"RestExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(List)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := RestExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapMostExpr wraps MostExpr for the pattern system
// Generated from pattern: Most(x_List)
func WrapMostExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"MostExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(List)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := MostExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapAssociationRules wraps AssociationRules for the pattern system
// Generated from pattern: Association(x___Rule)
func WrapAssociationRules(args []Expr, ctx *Context) Expr {

	// Handle empty case
	if len(args) == 0 {
		return CopyExprList(funcName, args)
	}

	// Handle single arg case
	if len(args) == 1 {
		result := AssociationRules(args[0])
		return result
	}

	// Convert all args to Expr
	convertedArgs := make([]Expr, len(args))
	for i, arg := range args {
		convertedArgs[i] = arg
	}

	// Call business logic function
	result := AssociationRules(convertedArgs...)

	// Convert result back to Expr
	return result
}

// WrapAssociationQExpr wraps AssociationQExpr for the pattern system
// Generated from pattern: AssociationQ(x_)
func WrapAssociationQExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"AssociationQExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := AssociationQExpr(arg0)

	// Convert result back to Expr
	return NewBoolAtom(result)
}

// WrapKeysExpr wraps KeysExpr for the pattern system
// Generated from pattern: Keys(x_Association)
func WrapKeysExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"KeysExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(ObjectExpr)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := KeysExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapValuesExpr wraps ValuesExpr for the pattern system
// Generated from pattern: Values(x_Association)
func WrapValuesExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"ValuesExpr expects 1 arguments", args)
	}

	arg0, ok := args[0].(ObjectExpr)
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := ValuesExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapNotExpr wraps NotExpr for the pattern system
// Generated from pattern: Not(x_)
func WrapNotExpr(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 1 {
		return NewErrorExpr("ArgumentError",
			"NotExpr expects 1 arguments", args)
	}

	arg0 := args[0]

	// Call business logic function
	result := NotExpr(arg0)

	// Convert result back to Expr
	return result
}

// WrapPartList wraps PartList for the pattern system
// Generated from pattern: Part(x_List, i_Integer)
func WrapPartList(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"PartList expects 2 arguments", args)
	}

	arg0, ok := args[0].(List)
	if !ok {
		return CopyExprList("FUNC", args)
	}
	arg1, ok := ExtractInt64(args[1])
	if !ok {
		return CopyExprList("FUNC", args)
	}

	// Call business logic function
	result := PartList(arg0, arg1)

	// Convert result back to Expr
	return result
}

// WrapPartAssociation wraps PartAssociation for the pattern system
// Generated from pattern: Part(x_Association, y_)
func WrapPartAssociation(args []Expr, ctx *Context) Expr {
	// Validate argument count
	if len(args) != 2 {
		return NewErrorExpr("ArgumentError",
			"PartAssociation expects 2 arguments", args)
	}

	arg0, ok := args[0].(ObjectExpr)
	if !ok {
		return CopyExprList("FUNC", args)
	}
	arg1 := args[1]

	// Call business logic function
	result := PartAssociation(arg0, arg1)

	// Convert result back to Expr
	return result
}
